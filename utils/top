
--{{{  stuff to try

always remove if statements if it's possible with loopup tables. e.g. makemove.
flatten all arrays and use Math.imul() or << n diy.
simplify piece counts etc out. but need a way to detect KK KNK etc.
remove all magic numbers based on cp/eval like in futility pruning etc. how? dunno. i.e. make lozza independent of eval scale.
swapping move list psts for move ranking based on queens on board or not - poss in position
reduce depth on lower bound
soft/hard time bounds
try iir if no hash move after iid?
decrease depth if IID fails
try no iid and no iir
take pv out of tt
root sort
rank killers before captures
try killers in qs (bad takes)
add centre to noisy ranking to stop lots of same scores e.g. NxP
add centre to his scores for noise.
don't use rank vec, use piece itself
try ignore beta when beta pruning
ditto alpha with alpha pruning and futility
quicksee in slide ranking
output buckets based on game phase or numpieces (available) or mid/end game etc
corrhist
conthist
improving - use more
lmp - tell move iterator - quicker
remove king from isattached etc - dont capture king - castle conditionals a la cwtch - tried but not working
try and get rid of MATERIAL - only used in QS prune now
move drawn stuff from eval into isdraw
full width window searches based on movetime not constant - e.g. log?
push harry

--}}}
--{{{  // Lozza bullet net (768 -> 128)x2 -> 1 sqrrelu
//
// Lozza bullet net (768 -> 128)x2 -> 1 sqrrelu
//

const OUTPUT_DIR: &str = "/home/xyzzy/lozza/nets/blooper";
const DATA_FILES: [&str; 2] = [
  "/home/xyzzy/lozza/data/gen5.bullet",
  "/home/xyzzy/lozza/data/gen4.bullet",
];

use bullet_lib::{
    nn::{
        optimiser,
        Activation,
    },
    trainer::{
        default::{
          inputs,
          loader,
          outputs,
          Loss,
          TrainerBuilder,
        },
        schedule::{
          lr,
          wdl,
          TrainingSchedule,
          TrainingSteps,
        },
        settings::LocalSettings,
    },
};

fn main() {

    let mut trainer = TrainerBuilder::default()
        .quantisations(&[255, 64])
        .optimiser(optimiser::RAdam)
        .loss_fn(Loss::SigmoidMSE)
        .input(inputs::Chess768)
        .output_buckets(outputs::Single)
        .feature_transformer(128)
        .activate(Activation::SqrReLU)
        .add_layer(1)
        .build();

    let schedule = TrainingSchedule {
        net_id: "lozza".to_string(),
        eval_scale: 400.0,
        steps: TrainingSteps {
            batch_size: 16_384,
            batches_per_superbatch: 6104,
            start_superbatch: 1,
            end_superbatch: 1000,
        },
        wdl_scheduler: wdl::ConstantWDL {
            value: 0.4
        },
        lr_scheduler: lr::StepLR {
            start: 0.001,
            gamma: 0.3,
            step: 300,
        },
        save_rate: 1,
    };

    //trainer.set_optimiser_params(optimiser::AdamWParams::default());

    let settings = LocalSettings {
        threads: 4,
        test_set: None,
        output_directory: &OUTPUT_DIR,
        batch_queue_size: 64,
    };

    let data_loader = loader::DirectSequentialDataLoader::new(&DATA_FILES);

    trainer.run(&schedule, &settings, &data_loader);
}

--}}}

'lozza.js'

'lozza.rs'
'datagen.js'
'loss.py'

----------------------------

'weights.js'

'lozzacand.js'
'lozzarepo.js'

'nets/bumpy/lozza.rs'

'releases/lozza5dev.js'    -- dev
'releases/lozza5rel.js'    -- as released with dev tt
'releases/lozza4.js'
'releases/lozza3.js'

'releases/5/lozza.js'      -- as released
'releases/5/lozza.bat'
'releases/5/readme.txt'

